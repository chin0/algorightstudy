# chapter2 정리

### 1.자료형 부울생김.
### 2. 참조형
- 쉽게 설명해서 어떤 변수에 하나의 이름을 더 붙여주는것이다.(태그를 붙인다고 생각하자.)
- 참조자에 대한 참조자도 선언 가능
- 선언과 동시에 초기화되어야함.
- NULL로 초기화할수없음.
- 포인터도 참조할수있음
- 참조하는 대상을 바꿀수없음.
```
int *ptr=&num;
int **pptr=&ptr;
int *(&pref) = ptr;
int **(&pptr) = pptr;
```
- 참조자는 call-by-reference의 함수호출을 진행할수있다.

```
void Swap(int &a,int &b)
{
    int temp=a;
    a=b;
    b=temp;
}
```
- 이것이 가능한 이유는 매개변수는 함수가 호출될때 초기화되기때문이다.
- 기본적으로 참조자 매개변수를 이용해 값을 바꾸지 않을때는 참조자를 const로 선언하는것이 조흔 습관이다.
- 반환형이 참조자인 경우
    - 받는 변수가 참조자일경우: 태그를 반환함(그 변수가 별명이 되는것임.)
    - 리턴값이 lvalue로 쓰일경우: 가리키고 있는 변수처럼 사용할수있음.
    - 받는 변수가 참조자도 아닌경우: 가리키고있는 변수의 값을 리턴.
- 상수화된 참조자만 상수화된 변수를 참조할수있다.
```
const int num=50;
const int &numref=num;
```
- 상수화된 참조자는 아래와 같이 상수를 참조할수도있다.
    - `const int &int=50`
    - 이 문장이 가능한이유는 50과 같은 상수를 리터럴이라고 부르는데, 이 리터럴은 임시적으로 존재하는 값이다. 다음 행으로 넘어가면 존재하지 않는 상수다. 그러므로 저 50도 일단은 어딘가의 메모리에 있지만, 다음행에 바로 없어지는 변수다.
    - 그래서 C++에서는 상수화된 참조자를 이용해 상수를 참조할때는, 임시변수를 만들어 그 변수를 참조하게 한다.
- 또한 힙에 할당된 변수도 참조할수있다.
    - new연산자를 이용해 할당한 메모리 공간도 변수로 간주한다.
    ```
    int *ptr=new int;
    int &ref=*ptr;
    ref=20;
    cout<<*ptr<<endl;
    ```
    - 
