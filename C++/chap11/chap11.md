# Chap 11 - 연산자오버로딩 2

## 대입연산자

대입 연산자 특징
- 정의하지 않으면 디폴트 대입 연산자가 삽입된다.
- 디폴트 대입 연산자는 멤버대멤버의 얕은 복사를 진행한다.
- 연산자 내에서 동적할당을 한다면, 그리고 깊은 복사가 필요하다면 직접 정의해야한다.

복사 생성자 특징
- 정의하지 않으면 디폴트 생성 연산자가 삽입된다.
- 디폴트 복사 생성자는 멤버대멤버의 얕은 복사를 진행한다.
- 생성자 내에서 동적할당을 한다면, 그리고 깊은 복사가 필요하다면 직접 정의해야한다.

둘다 매우 유사하다. 하지만, 호출되는 시점이 다르다.

복사 생성자가 호출되는 시점:
```
int main(void)
{
    Point pos1(5,7);
    Point pos2=pos1;
    ...
}
```
대입연산자가 호출되는 시점
```
int main(void)
{
    Point pos1(2,3);
    Point pos2(4,5);
    pos1=pos2;
    ...
}
```
- 기존에 생성된 두 객체간의 대입연산 시에는 대입 연산자가 호출된다.
- 멤버함수 방식의 오버로딩을 기준으로는, 아래와 같이 해석된다.
    - `pos.operator=(pos2)`
- 예제:FirstOperationOverloading.cpp
    - 한클래스는 대입연산자를 정의했고, 다른클래스는 정의하지않았다.
- 얕은 복사에 대한 문제점은 설명했고, 이는 복사 생성자와 같은 문제점이니 비슷하게 해결하면된다.
    - 다만, 복사 생성자와는 다르게 이미 생성된 멤버들로 연산을 하는것이므로 기존 멤버를 해제시키거나 상황에 따라서 별도의 연산을 더 해줘야한다.
    - 예를들어 문자열같은 경우는 대입 연산자 오버로딩 함수에서 먼저 기존 멤버의 값을 해제시켜주고 진행해야할것이다.
    - AssignDeepDarkCopy.cpp 참고
### 상속 구조에서의 대입 연산자 호출
- 유도클래스의 생성자에는 아무런 명시를 하지 않아도 기초 클래스의 생성자가 호출되지만, 유도클래스의 대입 연산자는 그렇지 않다!
- 즉, 유도클래스의 대입 연산자를 직접 정의해야할 경우에는 명시적으로 먼저 기초 클래스의 대입 연산자를 호출해줘야한다.
- 디폴트 대입 연산자는 알아서 먼저 호출해준다.

### 이니셜라이저의 성능향상 이유.

- 이니셜라이저는 선언과 동시에 초기화하는 바이너리 코드를 생성한다.
- 그래서 대입 연산자를 추가 호출하지않는다.

### 배열 인덱스 연산자 오버로딩
- ArrayClass.cpp참고.
- int arr[3]이 있을때 arr[2]를 분석해보면,
    - 객체 arr의 멤버함수 호출로 이어짐.
    - arr.operator[]를 호출할것임. 이것은 정수참조자를 반환하는 함수가 될것이다.
    - 인자는 정수형 2를 받는다.
- 즉, arr[2]는 arr.operator[]\(2\)로 해석된다.
- 불필요한 복사나 대입을 막고싶으면 대입 연산자오버로딩 함수와 복사 생성자를 private 멤버로 두면된다.
- 배열같은 경우는 복사나 대입이 안되는 자료형이기때문에 private로 막아두자.

### const를 활용한 연산자 오버로딩
- StableConstArrayProb.cpp 참고
- 36행에서 ShowAllData의 인자는 const형 참조자인데, operator[] 함수는 const함수가 아니기때문에 컴파일 에러를 띄운다.
- 전에 배웠던 대로 const의 유무도 오버로딩의 조건에 해당되기때문에 이를 이용하면 된다. (StableConstArraySolu.cpp참고)

### 객체의 저장을 위한 배열 클래스의 정의
- StablePointObjArray.cpp - Point객체를 저장하는 배열 클래스.
- StablePointPtrArray.cpp - Point객체의 주소를 저장하는 배열 클래스. - 이쪽이 깊은복사나 얕은 복사를 신경안써도되기때문에 더 많이 쓰인다.
