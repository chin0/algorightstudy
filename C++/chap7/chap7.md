# chap7 - 상속!
- 객체지향에서 가장 중요한 요소중 하나인 상속이다.
- 상속은 적용이 특히 중요한 문법이다.
- 상속의 문법적 요소뿐만 아니라 상속이 가져다주는 이점을 확실히 이해하자.
- 책의 시나리오를 따라하면서 느낀것 정리.

### 상속이란?

- 어느 클래스의 모든 멤버를 물려받는것.
- 상속의 방법
    - 일단 Person 클래스를 정의해보겠다.

```
class Person
{
private:
    int age;
    char name[50];
public:
    Person(int myage, char *myname) : age(myage)
    {
        strcpy(name,myname);
    }
    //항상 멤버변수의 값의 변환이 일어나지 않는 함수는 const를 꼭 붙여주자.
    void WhatYourName() const
    {
        cout<<"My name is "<<name<<endl;
    }
    void HowOldAreYou() const
    {
        cout<<"I'm "<<age<<" years old"<<endl;
    }
};
```
- 이제, Person클래스를 상속받는 UnivStudent 클래스를 정의하겠다.

```
class UnivStudent : public Person // Person 클래스의 상속을 의미.
{
private:
    char major[50];
public:
    UnivStudent(char *myname, int myage, char *mymajor)
        : Person(myage, myname) // 왜 상속받은 클래스를 따로 초기화시켜줄까??
    {
        strcpy(major,mymajor);
    }
    //HowOldAreYou,WhatYourName 멤버가 정의되어있지 않음에도 불구하고 호출이가능하다.(상속받았기때문)
    void WhoAreYou() const
    {
        WhatYourName();
        HowOldAreYou();
        cout<<"My major is "<<major<<endl<<endl;
    }
};
```

- 위 클래스에서 Person클래스를 public상속(가장 일반적. 의미는 나중에)
    - 위 상속받은 클래스의 객체가 생성되었을때 모습을 그림으로 표현하면...

```
UnivStudent 객체
------------------
|     age        |       |-------------------------|
|     name       |------>| 상속받은 Person클래스의멤버 |
| WhatYourName() |------>|-------------------------|
| HowOldAreYou() |
------------------
|   major        |      |-----------------------|
|   WhoAreYou    | ---->| UnivStudent의 멤버     |
------------------      |-----------------------|
```
- 위 그림과 같이 상속의 대상이 되는 클래스의 멤버까지도 객체내에 포함된다.

### 상속받은 클래스의 생성자 정의

```
UnivStudent(char *myname, int myage, char *mymajor)
    : Person(myage, myname) // 왜 상속받은 클래스를 따로 초기화시켜줄까??
{
    strcpy(major,mymajor);
}
```
- 다시 UnivStudent의 생성자를 보면 상태가 조금 이상하다.
- 위와 같이 초기화하는 이유는 다음과 같다.
    - UnivStudent 클래스의 생성자는 자신이 상속한 Person 클래스의 멤버를 초기화할 의무가 있다.
    - 그래서 UnivStudent의 생성자는 Person의 생성자를 호출하여(상속받은 클래스의 생성자를 호출하는게 가장 안정적이기 때문.) Person 클래스의 멤버를 초기화한다.
- 종합코드: UnivStudentInheri.cpp
- UnivStudent클래스의 멤버함수(또는 생성자)내에서는 Person 클래스에 private으로 선언된 멤버변수 age와 name에 접근이 가능한가?
    - 접근제한의 기준은 클래스이기때문에 클래스 외부에서는 접근할수없다. 고로, UnivStudent멤버함수 내에서는 Person멤버변수에 직접 접근이 불가능하다.
    - 즉, 정보은닉은 하나의 객체 내에서도 진행이된다.

### 용어정리

| Person  | UnivStudent |
| :------------: | :-----------: |
| 상위 클래스    | 하위클래스    |
| 기초(base) 클래스   | 유도(derived)클래스      |
| 슈퍼(super) 클래스  | 서브(sub) 클래스
| 부모 클래스         | 자식 클래스 |

- C++에서는 기초 - 유도 클래스라는 표현을 많이 쓴다 카더라.

### 유도 클래스의 객체 생성과정(중요)
- 소스코드: DerivCreOrder.cpp
- 출력값을 관찰하면 다음과 같은 답을 얻을수있다.
    - 유도클래스의 객체생성과정에는 생성자가 두번 호출된다.
    - 유도 클래스의 객체생성 과정에서 기초클래스의 생성자는 100% 호출된다.
    - 유도클래스의 생성자에서 기초 클래스의 생성자 호출을 명시하지 않으면, 기초 클래스의 void 생성자가 호출된다.

#### 유도 클래스 객체의 소멸과정
- 소멸자도 **2**번 호출된다. (콩콩!@!@)
- 소멸자도 **2**번 호출된다. (콩콩!@!@)
- 소스코드: DerivDestOrder.cpp

- 출력결과 분석결과는 아래와 같다.
    - 먼저 유도클래스의 소멸자가 호출된 후, 기초클래스의 소멸자가 호출된다.
    - 스택에 생성된 객체의 소멸순서는 생성순서와 반대이다.
    - 위 규칙에 따라서,생성자에서 동적할당한 메모리공간은 소멸자에서 해제한다.
        - 소스코드: DestModel.cpp

## protected와 세가지 형태의 상속
- protected - private와 비슷하지만, 이를 상속받는 유도클래스는 이 범위의 변수에 접근할수있음
    - 자주 사용되지는 않는다. 기초 클래스와 이를 상속하느 유도 클래스 사이에서도 '정보은닉'은 지켜지는것이 좋기 때문이다.

3가지 형태의 상속
- protected 상속 - protected보다 접근범위가 더 넓은 멤버는 강제로 protected로 낮춘다.
    - private: 접근불가
    - public: protected로 바꿔짐.
    - protected: 그대로
- private - 모든 멤버를 private로 바꿔 상속시킨다. -> 모든 멤버가 접근불가다. -> 상속의 의미가 퇴색된다.
- public - 가장 일반적.

## 상속을 위한 조건

- 상속으로 클래스간의 관계를 나타내기위해서는 조건이 필요한데, 이 조건과 그에 따른 필요가 충족되지 않으면 상속은 안하는게 더 낫다.


#### 조건 1 - is a (~이다)

- 유도 클래스는 기초클래스가 지니는 모든것을 지니고, 거기에다가 유도 클래스만의 추가적인 특성이 더해진다.
- 이를 현실세계에서 표현하자면
- 예를들어,
    - 무선 전화기는 일종의 전화기다.
    - 노트북 컴퓨터는 일종의 컴퓨터다.
- 즉, 상속관계가 성립하려면 IS-A 관계가 성립해야한다.
- 만약 위와 같은 관계가 성립되어지지 않는다면 그 상속은 적절한 상속의 관계가 아닐 확률이 높다.
    - 고로 매우 신중하게 판단해야한다.
- 예제: ISAInheritance.cpp
    - 이 소스에서 각 객체간의 관계를 현실세계로 나타내면 아래와 같다.
    - NotebookComp(노트북 컴퓨터)는 Computer이다.
    - TabletNotebook은 NotebookComp다.
    - TabletNotebook는 Computer이다.
- 위를 UML표기법으로 나타낼수있는데, 이건 책보자. 그리고 많이 사용되는 표기법이니 알아두면 좋다.

#### 다른 조건 - has-a
- 상속의 조건은 되지만 복합관계로 이를 대신하는것이 일반적이다.
- 이같은 경우에는 멤버변수에 그냥 포함되는 클래스를 넣어주는것이 더 좋다.
- 이 경우 상속을 하게될경우 유연성이 떨어지는 프로그램을 작성할 가능성이 높다.
    - 상속으로 묶인 두 개의 클래스는 강한 연관성을Elsek.

### etc
- 컨트롤 클래스의 특징
    - 프로그램 전체의 기능을 담당한다. -> 기능적 성격이 강한 클래스.
    - 컨트롤 클래스만 봐도 프로그램의 전체 기능과 흐름을 파악할수있음.
- Entity 클래스
    - 컨트롤 클래스를 제외한 대부분의 클래스를 말함.
    - 데이터적 성격이 강함. 따라서 파일 및 데이터 베이스에 저장되는 데이터를 소유하고있음.
    - 프로그램의 기능을 파악하는데는 도움이 되진 않지만, 데이터의 종류를 파악하는데는 도움이 된다.
