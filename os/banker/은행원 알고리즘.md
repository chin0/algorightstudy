# 은행원 알고리즘



- Deadlock Avoidance 알고리즘 중 하나로, 리소스 할당을 돈을 갚아주고 갚는 은행의 업무에 비유하여 고안된 알고리즘이다.
- 예를들어, 은행에 1000만원이 있다. 그리고 3명의 고객이 은행에서 돈을 빌린다. 은행은 고객이 원하는 돈을 다 빌려주면 바로 반환받을수있지만, 돈을 다 빌려주기 전까지는 강제로 반환받지 못한다.
- 위와 같은 상황에서 아래와 같은 예를보자.
  - 고객1이 총 600만원을 빌리고자 한다.
  - 고객2가 총 800만원을 빌리고자 한다.
  - 고객 3이 총 400만원을 빌리고자 한다.
  - 이 경우 1-2-3, 1-3-2, 2-3-1 등 모든 경우가 다 가능하기때문에 safe하다.
    - 한꺼번에 돈을 다 빌려주고 받은후 다음 고객한테 주면 되기 때문이다.
- 하지만 위와 같은 예랑은 다르게, 대부분 은행은 돈을 한꺼번에 빌려주는경우가 별로 없다. 아래 경우를 보자.
  - 고객1한테 300만원을 빌려주고 300만원을 더 빌려줘야한다.
  - 고객2한테 400만원을 빌려주고 400만원을 더 빌려줘야한다.
  - 고객3한테 100만원을 빌려주고 300만원을 더 빌려줘야한다.
    - 위와 같은경우 빌려줄수있는돈(할당가능 리소스)는 200만원이 남았지만 고객(프로세스)들은 더 큰 돈을 요구한다. 이런 경우를 deadlock이라고 하는데, 이런 unsafe한 상황을 고치기 위한 알고리즘이 은행원 알고리즘이다.
- 그리고 만약, 아래와 같은 상황을 보자.
  - 고객1한테 200만원을 빌려주고 400만원을 더 빌려줘야한다.
  - 고객2한테 400만원을 빌려주고 400만원을 더 빌려줘야한다.
  - 고객3한테 100만원을 빌려주고 300만원을 더 빌려줘야한다.
  - 위와같은 상황에서는 돈이 300만원이 남지만 고객이 100원을 더 빌려달라고한다. 남은돈 300만원을 고객 3한테 빌려주고 돌려받을수있기때문에 일단은 safe하지만 고객1한테 100만원을 빌려주는 순간 은행은 파산한다.(unsafe)
- 위와 같은 case들을 방지하는게 은행원 알고리즘이다.



## Implementation

자료구조

- p - 프로세스의 개수.
- r - 리소스 타입의 수
- Available - 1차원 배열, 각 리소스 타임별로 남은 인스턴스 정보를 나타냄. available[j]는 리소스 j의 남은 인스턴스를 의미함.(사용 가능한 리소스의 양.)
- Max - 2차원 배열, 프로세스가 i가 j타입의 리소스를 최대로 얼마나 요구할 것인가를 max\[i]\[j]로 나타낸다.
- Allocation: 이차원 배열, 프로세스 i에 j타입의 리소스가 얼마나 할당되어 있는지를 allocation\[i]\[j]로 나타냄.
- Need: 이차원 배열, 프로세스 i가 필요로하는 j타입의 리소스가 얼마나 남았는가를 need\[i]\[j]로 나타낸다.(Need = Max - Allocation)
- Complete: 완료된 프로세스
- Safe한 상태는? 요구하는 할당량을 충족하는 프로세스들의 시퀀스를 하나라도 만들어낼수있으면 true(시퀀스=수열)

알고리즘

- 1. Need가 가장 적은 프로세스를 찾는다.
  2. Need의 각 요소와 Available비교한다.
     1. 적으면 Available의 각 요소와 Max의 각 요소를 더해주면 됨.
  3. 1-2를 반복하면서 모든 프로세스가 Complete에 들어가면 safe, 안들어가면 unsafe



## To-do

1. 알고리즘 작동과정 출력
2. 더 보기좋게 출력문 다듬기
3. 비효율적인 부분 수정 4. 코드 해석하기좋게 변수명 다듬고 주석작성및 코드 리펙토링
4. 멀티스레드 프로그램에 적용시켜보기.
